# 付録A 統計的検定と指標の定義

本付録では，本プロジェクトで用いた主な指標と統計的検定の計算式を整理する。本文では結果の概要に留め，詳細な式はここにまとめて示す。

## A.1 制約遵守率

ある条件（生成方式や制約タイプなど）において，生成した文の総数を \(N\)，そのうち制約違反が一度も検出されなかった文の数を \(N_{\text{success}}\) とする。このとき，読みベース制約遵守率（Constraint Satisfaction Rate）は次式で定義する。

\[
\text{ConstraintRate} = \frac{N_{\text{success}}}{N}
\]

必要に応じて百分率（％）表示とする場合には，この値に 100 を掛ける。

## A.2 VRR と TTR

### A.2.1 語彙置換率（VRR）

元文のトークン列を \(X = (x_1, x_2, \dots, x_n)\)，生成文のトークン列を \(Y = (y_1, y_2, \dots, y_m)\) とする。簡便化のため，実装ではトークン列の差分から「置き換わったトークン」の集合 \(X_{\text{diff}}\) を近似的に求め，その大きさを \(|X_{\text{diff}}|\)，元文のトークン数を \(|X|\) とすると，語彙置換率（Vocabulary Replacement Rate; VRR）は次式で定義される。

\[
\text{VRR} = \frac{\left| X_{\text{diff}} \right|}{\left| X \right|}
\]

値が 0 に近いほど元文に近い表現が保たれており，1 に近いほど多くのトークンが置き換わっていることを意味する。

### A.2.2 語彙多様性（TTR）

生成文のトークン列を \(Y\)，その中に出現するユニーク語彙の集合を \(\text{types}(Y)\) とする。このとき，語彙多様性（Type-Token Ratio; TTR）は次式で定義される。

\[
\text{TTR} = \frac{\left| \text{types}(Y) \right|}{\left| Y \right|}
\]

TTR は「どれだけ多様な語彙が使われているか」を表し，0〜1の範囲の値をとる。

## A.3 対応のある t 検定（paired t-test）

二つの生成方式（oneshot / sequential）を同一の入力文集合に対して適用し，方式ごとに指標値（例：成功フラグ，VRR など）を得た場合，入力文ごとに「ペア」を作ることができる。このとき，二方式間の平均値の差を評価するために対応のある t 検定を用いる。

入力文 \(i = 1, 2, \dots, n\) ごとに，oneshot の指標値を \(x_i\)，sequential の指標値を \(y_i\) とし，差分 \(d_i = y_i - x_i\) を定義する。差分の平均を \(\bar{d}\)，標本標準偏差を \(s_d\) とすると，対応のある t 検定の統計量 \(t\) は次式で与えられる。

\[
t = \frac{\bar{d}}{s_d / \sqrt{n}}
\]

ここで，

\[
\bar{d} = \frac{1}{n} \sum_{i=1}^{n} d_i, \quad
s_d = \sqrt{ \frac{1}{n-1} \sum_{i=1}^{n} (d_i - \bar{d})^2 }.
\]

自由度は \(n-1\) とし，この \(t\) 値に対する p 値を，両側検定（two-sided test）で評価する。本研究では有意水準 \(\alpha = 0.05\) を基準とし，p 値がこれより十分に小さい場合（例えば \(p \ll 0.001\)）に「方式間の差は統計的に有意である」と判断した。

成功フラグのような 0/1 指標に対しても，同じ入力文に対する二方式の結果がペアで得られているため，同様に \(d_i \in \{-1, 0, 1\}\) を用いて対応のある t 検定を適用した。

## A.4 実装例（Python による計算）

実際の統計量と p 値の計算は，Python（pandas, SciPy）を用いて自動化した。以下に，対応のある t 検定を適用する簡略化したコード例を示す。

```python
import pandas as pd
from scipy import stats

# 実験結果の読み込み（例：results_500.csv）
df = pd.read_csv("results/results_500.csv")

# 制約違反フラグから success 列を作成
df["success"] = ~df["constraint_violated"]

# id ごとに oneshot / sequential を横持ちにする
wide = df.pivot_table(
    index="id",
    columns="method",
    values=["success", "vrr", "ttr"],
    aggfunc="first",
)
wide.columns = [f"{v}_{m}" for v, m in wide.columns]
wide = wide.reset_index()

#
# 1. 成功フラグ (0/1) に対する対応のある t 検定  → RQ1
#
success_seq = wide["success_sequential"].astype(float)
success_one = wide["success_oneshot"].astype(float)
t_success, p_success = stats.ttest_rel(success_seq, success_one)
print("Success (sequential vs oneshot): t =", t_success, "p =", p_success)

#
# 2. 両方式とも成功したペアに対する VRR の t 検定 → RQ2
#
both_ok = wide[(wide["success_sequential"] == True) &
               (wide["success_oneshot"] == True)]
vrr_seq = both_ok["vrr_sequential"]
vrr_one = both_ok["vrr_oneshot"]
t_vrr, p_vrr = stats.ttest_rel(vrr_seq, vrr_one)
print("VRR (sequential vs oneshot, both success): t =", t_vrr, "p =", p_vrr)
```

上記のコードは，本文第5章で報告した「成功率の差」「VRR の差」に対する t 値と p 値を再現するための最小限の例である。実際の解析では，これに加えて制約タイプごとの集計や図表生成（plot_results.py）も行っている。

## A.5 方法別の基礎統計量

本文では主に平均値と差の有意性に着目したが，再現性の観点から，方法別の基礎統計量（平均・標準偏差・中央値・四分位範囲）の一覧を表形式で整理しておくと有用である。例えば，sequential / oneshot のそれぞれについて，VRR・TTR・time_sec（1文あたりの実行時間）について，

- 平均値（mean）  
- 標準偏差（standard deviation）  
- 中央値（median）  
- 四分位範囲（IQR: 第1四分位数〜第3四分位数）  

を計算し，表A.1 のような形でまとめることができる。

表A.1 に，results_500.csv に対して `scripts/calc_stats_summary.py` を適用して得られた基礎統計量を示す。

表A.1 方法別の基礎統計量（N=465）

| 指標     | method     | mean   | sd      | median | IQR    | N   |
|----------|------------|--------|---------|--------|--------|-----|
| VRR      | oneshot    | 0.422  | 0.209   | 0.417  | 0.278  | 465 |
| VRR      | sequential | 0.180  | 0.101   | 0.167  | 0.136  | 465 |
| TTR      | oneshot    | 0.934  | 0.070   | 0.938  | 0.091  | 465 |
| TTR      | sequential | 0.919  | 0.084   | 0.938  | 0.125  | 465 |
| time_sec | oneshot    | 0.696  | 0.226   | 0.615  | 0.272  | 465 |
| time_sec | sequential | 7.188  | 29.869  | 2.631  | 4.716  | 465 |

## A.6 制約タイプ別の成功率

また，制約タイプ（easy / medium など）ごとの成功率と件数も，本文の議論（特に RQ3）を裏付ける補助情報として表にまとめることができる。例えば，constraint_type × method ごとに

- 文数 \(N\)  
- 成功率（ConstraintRate）  

を計算し，表A.2 として整理する。

表A.2 に，制約タイプ別 × 方法別の成功率の要約を示す（success_rate は読みベース制約遵守率）。

表A.2 制約タイプ別 × 方法別の成功率（results_500.csv より集計）

| constraint_type | method     | N   | success_rate [%] |
|-----------------|------------|-----|------------------|
| easy            | oneshot    | 195 | （別途集計）     |
| easy            | sequential | 195 | （別途集計）     |
| medium          | oneshot    | 270 | （別途集計）     |
| medium          | sequential | 270 | （別途集計）     |

※ success_rate の具体的な値は，pandas の `groupby(["constraint_type","method"])["success"].mean()` などを用いて算出できる。
```
